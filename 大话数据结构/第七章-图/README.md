# 第七章-图

## 图的定义

图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为`G(V,E)`，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

### 各种图定义

**无向边（Edge）** ：若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对`(vi,vj)`来表示。

**无向图（Undirected graphs）** ：如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。

**有向边（Arc）** ：若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧，用有序偶`<vi,vj>`来表示，vi称为弧尾（Tail），vj称为弧头（Head）。

**有向图（Directed graphs）** ：如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。

**简单图** ：在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。

**无向完全图** ：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图，如下图所示：

![无向完全图](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9B%BE/images/1-full-undirected-graph.png?raw=true)

**有向完全图** ：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图，如下图所示：

![有向完全图](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9B%BE/images/2-full-directed-graph.png?raw=true)

**稀疏图/稠密图** ：有很少条边或弧的图称为稀疏图，反之称为稠密图，相对概念。

**权（Weight）** ：与图的边或弧相关的树，可以表示从一个顶点到另一个顶点的距离或耗费。

**网（Network）** ：带权的图通常称为网，如下图所示：

![网](images/3-network.png)

**子图（Subgraph）** ：假设有两个图 `G = (V, {E})`和`G' = (V', {E'})`，如果`V'`属于`V`且`E'`属于`E`，则称`G'`为`G`的子图。

### 图的顶点与边间关系

**顶点v的度degree** ：是和顶点v相连接的边的数目。对于有向图的顶点的度还分为出度和入度。
**邻接点** ：同一条边的两个点互为邻接点。
**路径** ：指从一个顶点到另一个顶点所经过的顶点的序列。树的路径唯一，但图的路径不唯一，所以有很多求最短路径的算法。在网络图中，路径又叫路由。
**路径的长度** ：路径上的边或弧的数目。
**回路或环** ：第一个顶点和最后一个顶点相同的路径。
**简单路径** ：路径序列中没有重复出现的顶点。
**简单回路** ：除了第一个和最后一个顶点相同外，其余的顶点都不相同。
**连通图（connected graph）** ：无向图中任意两个顶点都有路径（即都是连通的）。
**非连通图** ：存在两个顶点之间没有路径，即不连通。有n个顶点，但只有小于n-1条边，一定是非连通图。
**连通分量** ：无向图中的极大连通子图。连通图本身即是，而非连通图中最大的连通子图即是。
**强连通图** ：有向图中，任意两个顶点都存在双向连通的路径。有向图的非强连通图，对应有强连通分量。
**生成树** ：一个连通图的极小连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边（即去掉了环路）。不过n个顶点有n-1条边并不一定是生成树，比如一个非连通图中有一部分是个环路。因此生成树的前提一定是连通图。
**有向树** ：一个有向图恰有一个顶点的入度为0（根结点），其余顶点的入度均为1。
**生成森林** ：一个有向图的所有顶点，被分成若干颗不相交的有向树，这些有向树就组成了有向森林。

## 图的抽象数据类型

```
ADT 图(Graph)
Data
  顶点的有穷非空集合和边的集合。
Operation
  CreateGraph(*G, V, VR): 按照顶点集V和边弧集VR的定义构造图G。
  DestroyGraph(*G): 图G存在则销毁。
  LocateVex(G, u): 若图G中存在顶点u，则返回图中的位置。
  GetVex(G, v): 返回图G中顶点v的值。
  PutVex(G, v, value): 将图G中顶点v赋值value。
  FirstAdjVex(G, *v): 返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。
  NextAdjVex(G, v, *w): 返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回空。
  InsertVex(*G, v): 在图G中增添新顶点v。
  DeleteVex(*G, v): 删除图G中顶点v及其相关的弧。
  InsertArc(*G, v, w): 在图G中增添弧<v, w>，若G是无向图，还需要增添对称弧<w, v>。
  DeleteArc(*G, v, w): 在图G中删除弧<v, w>，若G是无向图，则还删除对称弧<w, v>。
  DFSTraverse(G): 对图G中进行深度优先遍历，在遍历过程对每个顶点调用。
  BFSTraverse(G): 对图G中进行广度优先遍历，在遍历过程对每个顶点调用。
endADT
```

## 图的存储结构

### 邻接矩阵

**图的邻接矩阵（Adjacency Matrix）** ：存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧信息。

下图为无向图及其邻接矩阵存储的示意图：

![无向图邻接矩阵](genlink(images/4-adjacency-matrix.png))

- 由于不存在顶点到自身的边，所以矩阵主对角线的值均为0；
- 无向图的边都是成对存在，故无向图的边数组是一个对称矩阵，即`aij = aji`。

下图为有向图及其邻接矩阵存储的示意图：

![有向图邻接矩阵](genlink(images/5-directed-adjacency-matrix.png))

- 顶点vi的入度是第vi列各数之和，出度是第vi行的各数之和。

网图的邻接矩阵中过保存权值，0表示`i = j`，`∞`代表不存在，如下图所示：

![网图邻接矩阵](genlink(images/6-network-adjacency-matrix.png))

### 邻接表

**邻接表（Adjacency List）** ：数组与链表相结合的图的存储方法。用一个一位数组存储图中的顶点，包括顶点信息和一个指向邻接点单链表的指针，如下图所示：

![无向图邻接表](genlink(images/7-adjacency-list.png))

无向图顶点v1关联的单链表称作顶点vi的边表，有向图顶点v1关联的单链表称作顶点vi作为弧尾的出边表。

有向图的邻接表结构是类似的，为了便于确定顶点的入度或以顶点为弧头的弧，可以建立一个有向图的逆邻接表，即对每个顶点vi都建立一个链接为v1为弧头的表，如下图所示：