# 第八章-查找

## 查找概论

**查找表（Search Table）** ：由同一类型的数据元素（或记录）构成的集合。

**关键字（Key）** ：数据元素中某个数据项的值。

**关键码** ：标识数据记录的某个数据项（字段）。

**主关键字（Primary Key）** ：可以唯一地标识一个记录的关键字。

**次关键字（Secondary Key）** ：可以识别多个数据元素（或记录）的关键字。

关键概念示例如下图所示：

![关键概念](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/images/1-concepts.png?raw=true)

**查找（Searching）** ：就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。

**静态查找表（Static Search Table）** ：只作查找操作的查找表。主要操作有：

1. 查询某个“特定的”数据元素是否在查找表中。
2. 检索某个“特定的”数据元素和各种属性。

**动态查找表（Dynamic Search Table）** ：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。主要操作有：

1. 查找时插入数据元素。
2. 查找时删除数据元素。

## 顺序表查找

**顺序查找（Sequential Search）** 又叫线性查找，是最基本的查找技术。

顺序查找的代码实现详见 [示例程序 sequential-search.c](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/example/8.1-sequential-search.c)。顺序查找的时间复杂度为`O(n)`。

## 有序表查找

### 二分查找

**二分查找（Binary Search）** ：前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复直至查找成功，或查找区域无记录，查找失败为止。

二分查找的代码实现详见 [示例程序 binary-search.c](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/example/8.2-binary-search.c)。二分查找的时间复杂度为`O(logn)`。

### 插值查找

**插值查找（Interpolation Search）** 是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式`(key - a[low]) / (a[high] - a[low])`。

插值查找只需更改二分查找中`mid`值的计算即可，代码实现详见 [示例程序 interpolation-search.c](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/example/8.3-interpolation-search.c)

### 斐波那契查找

裴波那契数列是一串按照F(0)=1，F(1)=1, F(n)=F(n-1)+F(n-2)（n>=2，n∈N*）这一条件递增的一串数字：`1、1、2、3、5、8、13、21 ... ...`，两个相邻项的比值会逐渐逼近0.618 —— 黄金分割比值。

斐波那契查找就是一个长度为f(n)的数组，它能被分成f(n-1)和f(n-2)这两半，递归查找。

二分查找， 插值查找和裴波那契查找的基础其实都是：对数组进行分割， 只是各自的标准不同： 二分是从数组的一半分， 插值是按预测的位置分， 而裴波那契是按它数列的数值分。

算法思想如下：

1. 创建裴波那契数组
2. 以1中的裴波那契数组的大于待查找数组的最小值为长度创建填充数组，将原待排序数组元素拷贝到填充数组中来， 如果有剩余的未赋值元素， 用原待查找数组的最后一个元素值填充
3. 针对填充数组进行关键字查找， 查找成功后记得判断该元素是否来源于后来填充的那部分元素，若为填充的元素，则返回最后一个元素下标即可

斐波那契数组、待查找数组、填充数组三者的关系如下图所示：

![斐波那契查找](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/images/2-fibonacci-search.jpg?raw=true)

斐波那契查找代码实现详见 [示例程序 fibonacci-search.c](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/example/8.4-fibonacci-search.c)


## 二叉排序树

**二叉排序树（Binary Sort Tree）** ：又称为二叉查找树。它或是一棵空树，或者是具有下列性质的树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结构的值；
- 它的左、右子树也分别为二叉排序树。

### 二叉排序树查找操作

二叉排序树的查找操作代码实现详见 [示例程序 search-bst.c](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/example/8.6-search-bst.c)

### 二叉排序树插入操作

二叉排序树的插入操作代码实现详见 [示例程序 insert-bst.c](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/example/8.7-insert-bst.c)

### 二叉排序树删除操作

删除操作比较复杂，有以下几种情况：

1. 待删除结点为叶子结点，直接删除即可；
2. 待删除结点仅有左子树，则删除后重接左子树；
3. 待删除结点仅有右子树，则删除后重接右子树；
4. 待删除结点左右子树都有，则寻找其直接前驱节点，数据拷贝至待删除结点，然后删除其前驱节点，这里还分两种情况（前提：前驱结点无右子树）：
   1. 前驱节点即为待删除结点左子节点，重接其左子树至待删除结点即可；
   2. 前驱结点非待删除结点左子节点，重接其左子树至其父节点的右子树即可。

二叉排序树的删除操作代码实现详见 [示例程序 delete-bst.c](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/example/8.8-delete-bst.c)

## 平衡二叉树（AVL树）

**平衡二叉树（Self-Balancing Binary Search Tree 或 Height-Balanced Binary SearchTree）** 是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。

**平衡因子BF（Balance Factor）** ：二叉树上结点的左子树深度减去右子树深度的值。平衡二叉树上所有结点的平衡因子只可能是-1， 0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。

**最小不平衡子树** ：距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树。

### 平衡二叉树实现原理

**基本思路** ：在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡树。

平衡二叉树的代码实现详见 [示例程序 avl.c](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/example/8.10-avl.c)

## 多路查找树（B树）

**多路查找树（multi-way search tree）** ，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。

多路查找树的**4种特殊形式：** ：`2-3树`、`2-3-4树`、`B树`、`B+树`。

### 2-3树

**2-3树是每一个结点都具有两个孩子（2结点）或三个孩子（3结点）的一棵多路查找树。**

一个**2结点**包含一个元素和两个孩子（或没有孩子），左子树包含的元素小于该元素，右子树包含的元素大于该元素。这个2结点要么没有孩子，要有就有两个，不能只有一个孩子。

一个**3结点**包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。并且2-3树中所有的叶子都在同一层次上。

![23树](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/images/3-23tree.png?raw=true)

### 2-3-4树

2-3-4树是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。

![234树](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/images/4-234tree.png?raw=true)

### B树

**B树（B-tree)** 是一种平衡的多路查找树，`2-3树`和`2-3-4树`都是B树的特例。结点最大的孩子数目称为B树的阶（order），因此，`2-3树`是3阶B树，`2-3-4树`是4阶B树。

一个m阶的B树具有如下属性：

- 如果根结点不是叶节点，则其至少有两颗子树；
- 每一个非根的分支结点都有k-1个元素和k个孩子，其中`[m/2] <= k <= m`。每一个叶子结点n都有k-1个元素，其中`[m/2] <= k <= m`；
- 所有叶子结点都位于同一层次；
- 所有分支结点包含下列信息数据`（n, A0, K1, A1, K2, A2, ..., Kn, An）`，其中：`Ki (i = 1, 2, ..., n)` 为关键字，且`Ki < Ki+1(i = 1, 2, ..., n)`; `Ai(i = 0, 1, 2, ...., n)`为指向子树根结点的指针，且指针`Ai-1`所指子树中所有结点的关键字均小于`Ki(i = 1, 2, ..., n)`，`An`所指子树中所有结点的关键字均大于`Kn`，`n([m/2] - 1 <= n <= m - 1)`为关键字的个数（或为子树的个数）。

![B树](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/images/5-b-tree.png?raw=true)

B树的数据结构就是为内外存的数据交互准备的：由于B树每节点可以有多个元素，减少了必须访问结点数和数据块的数量，从而提高了性能。

### B+树

B+树是应文件系统所需而出的一种B树的变形树，严格意义上讲，他其实已经不是第六章定义的树了。

在B+树中，出现在分支结点中的元素会被当作他们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。

![B+树](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/images/6-b+-tree.png?raw=true)

一棵m阶的B+树和m阶的B树的差异在于：

- 有n棵子树的结点中包含有n个关键字
- 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接
- 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字

如果是要随机查找，就从根结点出发，与B树的查找方式相同，不过即使在分支结点找到了待查找的关键字，也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。

如果从最小关键字进行从小到大的顺序查找，可以从最左侧的叶子结点出发，不经过分支结点，而是延着指向下一叶子的指针就可遍历所有的关键字。

B+树的插入、删除过程都与B树类似，不过插入和删除的元素都在叶子结点上进行。

## 散列表查找（哈希表）概述

**散列技术** 是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f（key）。

**散列函数/哈希（Hash）函数** ：建立关键字与存储位置间对应关系的函数。

**散列表/哈希表（Hash Table）** ：采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。

### 散列表查找步骤

1. 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。
2. 在查找记录时，通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。

**散列技术既是一种存储方法，也是一种查找方法。**

**散列技术最适合的求解问题是查找与给定值相等的记录。**

**散列冲突（collision）** ：两个关键字`key1`不等于`key2`，但是却有`f(key1) = f(key2)`的现象。`key1`和`key2`称为这个散列函数的**同义词(synonym)** 。

## 散列函数的构造方法

散列函数设计原则：

1. 计算简单
2. 散列地址分布均匀

### 直接定址法

取关键字的某个线性函数值为散列地址：`f(key) = a x key + b` (a、b为常数)。

**优点** ：简单、均匀，不会产生冲突。

**缺点** ：需要事先知道关键字的分布情况，适合查找表较小且连续的情况，故不常用。

### 数字分析法

**抽取** ：使用关键字的一部分来计算散列存储位置。

数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，可以考虑使用。

### 平方取中法

关键字求平方后取中间若干位，用作散列地址。

平法取中法适合于不知道关键字的分布，而位数又不是很大的情况。

### 折叠法

折叠法是将关键字从左到右分割成位数相等的几部分（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。

折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。

### 除留余数法

对于散列表长为m的散列函数公式为：`f(key) = key mod p (p <= m)`。

`mod`是取模（求余数）的意思。事实上，这方法不仅可以对关键字直接取模，也可以在折叠、平方取中后再取模。

通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数。

### 随机数法

选择一个随机数，取关键字的随机函数值为它的散列地址。`f(key) = random(key)`。

当关键字的长度不相等时，采用这个方法构造散列函数是比较合适的。

## 处理散列冲突的方法

### 开放定址法

一旦发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。

`fi(key) = (f(key) + di) MOD m ` `(di = 1, 2, 3, ..., m - 1)`

**线性探测法** ：依次往后寻找空散列地址的开发定址法。

**堆积** ：本来都不是同义词却需要争夺一个地址的情况。

**二次探测法** ：在寻找空散列地址时，双向寻找，并增加平方运算的开放定址法。（增加平方运算的目的是为了不让关键字都聚集在某一块区域）。

`fi(key) = (f(key) + di) MOD m` `(di = 1^2, -1^2, 2^2, -2^, ..., q^2, -q^2, q <= m / 2)`

**随机探测法** ：在冲突时，对于位移量di采用随机函数计算得到。

### 再散列函数法

准备多个散列函数，发生冲突时，就换一个散列函数计算。

`fi(key) = RHi(key)` `(i = 1, 2, ..., k)`

### 链地址法/拉链法

将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。

![链地址法](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/images/7-hash-table-1.png?raw=true)

### 公共溢出区法

为所有冲突的关键字建立一个公共的溢出区来存放。

![公共溢出区法](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/images/8hash-table-2.png?raw=true)

在冲突数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。

## 散列表查找实现

散列表查找代码实现详见 [示例程序 hash-table.c](https://github.com/logan70/Data-Structures-and-Algorithms/blob/master/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9F%A5%E6%89%BE/example/8.11-hash-table.c)

### 散列表查找性能分析

散列表如果没有冲突，查找的时间复杂度为`O(1)`。

但是只是理想情况，散列查找的平均查找长度取决于下列因素：

1. 散列函数是否均匀
2. 处理冲突的方法
3. 散列表的装填因子：（`α = 填入表中的记录个数 / 散列表长度`），α越大，产生冲突的可能性就越大

